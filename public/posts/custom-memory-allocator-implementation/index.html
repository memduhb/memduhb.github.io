<!doctype html><html lang=en><head><title>Implementing Custom Memory Allocator in C++ · memduh</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="memduh"><meta name=description content="A detailed implementation guide for custom memory allocator functions including malloc, calloc, realloc, and free in C++, with educational insights into memory management."><meta name=keywords content="C++,memory,allocators,mmap,slab,performance"><meta name=twitter:card content="summary"><meta name=twitter:title content="Implementing Custom Memory Allocator in C++"><meta name=twitter:description content="A detailed implementation guide for custom memory allocator functions including malloc, calloc, realloc, and free in C++, with educational insights into memory management."><meta property="og:url" content="/posts/custom-memory-allocator-implementation/"><meta property="og:site_name" content="memduh"><meta property="og:title" content="Implementing Custom Memory Allocator in C++"><meta property="og:description" content="A detailed implementation guide for custom memory allocator functions including malloc, calloc, realloc, and free in C++, with educational insights into memory management."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-08-06T10:00:00+03:00"><meta property="article:modified_time" content="2025-08-06T10:00:00+03:00"><meta property="og:see_also" content="/posts/implementing-custom-thread-pool-cpp/"><meta property="og:see_also" content="/posts/slab-allocator-implementation/"><link rel=canonical href=/posts/custom-memory-allocator-implementation/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.6445a802b9389c9660e1b07b724dcf5718b1065ed2d71b4eeaf981cc7cc5fc46.css integrity="sha256-ZEWoArk4nJZg4bB7ck3PVxixBl7S1xtO6vmBzHzF/EY=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/custom.min.0c7feecd432e394a9caa60d61320988a393b7b9a7c0ae204d73b7ce6e142b10c.css integrity="sha256-DH/uzUMuOUqcqmDWEyCYijk7e5p8CuIE1zt85uFCsQw=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>memduh
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>posts</a></li><li class=navigation-item><a class=navigation-link href=/notes/>notes</a></li><li class=navigation-item><a class=navigation-link href=/readings/>readings</a></li><li class=navigation-item><a class=navigation-link href=/about/>about</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=/posts/custom-memory-allocator-implementation/>Implementing Custom Memory Allocator in C++</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa-solid fa-calendar" aria-hidden=true></i>
<time datetime=2025-08-06T10:00:00+03:00>August 6, 2025
</time></span><span class=reading-time><i class="fa-solid fa-clock" aria-hidden=true></i>
6-minute read</span></div><div class=categories><i class="fa-solid fa-folder" aria-hidden=true></i>
<a href=/categories/systems-programming/>Systems-Programming</a></div></div></header><div class=post-content><p>In this post, I elaborate on my implementation of a memory allocator in C++. The <code>malloc</code>, <code>calloc</code>, <code>realloc</code>, and <code>free</code> functions are implemented and discussed. The aim is to provide educational content on how these functions work under the hood. Not all aspects are taken into account in this custom implementation; however, this provides a sufficient introduction to memory management in C++. Note that standard allocators like <strong>glibc malloc</strong> are highly optimized and have been battle-tested for decades.</p><p>We first start with a function to handle memory allocation: our <code>request_memory_from_os</code> function requests memory from the OS using <a href=https://man7.org/linux/man-pages/man2/mmap.2.html class=external-link target=_blank rel=noopener><code>mmap</code></a>. What <code>mmap</code> simply does is create a new mapping in the virtual address space of the calling process. We also need to bear in mind that we will request multiples of our operating system&rsquo;s page size. In our case, this is 16 kB, though traditionally this may be 4 kB in many systems.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>request_memory_from_os</span>(std<span style=color:#f92672>::</span>size_t size) {
</span></span><span style=display:flex><span>    size_t page_size <span style=color:#f92672>=</span> getpagesize();
</span></span><span style=display:flex><span>    size_t aligned_size <span style=color:#f92672>=</span> ((size <span style=color:#f92672>+</span> <span style=color:#66d9ef>sizeof</span>(BlockHeader) <span style=color:#f92672>+</span> page_size <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>/</span> page_size) <span style=color:#f92672>*</span> page_size;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> ptr <span style=color:#f92672>=</span> mmap(NULL, aligned_size, PROT_READ <span style=color:#f92672>|</span> PROT_WRITE, MAP_PRIVATE <span style=color:#f92672>|</span> MAP_ANONYMOUS, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0u</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (ptr <span style=color:#f92672>==</span> MAP_FAILED)
</span></span><span style=display:flex><span>        handle_error(<span style=color:#e6db74>&#34;mmap&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ptr;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Note that we align the block&rsquo;s size according to the requested size plus the size of the block header (the extra info we mentioned previously).</p><p>In our case, the <code>BlockHeader</code> is a simple struct storing the size, the availability of that block, and a link to the next block. This totals 24 bytes (8 bytes for size, 1 byte for the boolean, 8 bytes for the pointer to the next <code>BlockHeader</code>, and 7 bytes of padding due to memory alignment on our 64-bit system).</p><p>To finalize the function, we use <code>mmap</code> to return a pointer to the allocated memory region.</p><hr><h3 id=malloc><strong>Malloc</strong>
<a class=heading-link href=#malloc><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>We continue with <code>malloc</code>: <code>void *malloc(size_t size)</code> allocates <code>size</code> bytes of uninitialized storage and returns a pointer to the allocated memory. We intend to mimic this behavior in our custom allocator.</p><p>We also need to note that in <code>malloc</code>, a bit more memory than we ask for is allocated. This is to store extra information, such as the allocated block&rsquo;s size and a link to the next free block in memory. We actually took care of this in our <code>request_memory_from_os</code> function, which is what we will use within our <code>malloc</code>.</p><p>In <code>malloc</code>, we first check if there is already a free block in the free list. These blocks occur due to the use of <code>free</code> to release regions of allocated memory. If no free block is found, we allocate a new region of memory with <code>mmap</code>. Also, note that we return the usable memory — namely, <code>header + 1</code> — as the return pointer.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>my_malloc_internal</span>(size_t size) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// First check if there is a free block in the free list
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    BlockHeader<span style=color:#f92672>*</span> prev <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>    BlockHeader<span style=color:#f92672>*</span> curr <span style=color:#f92672>=</span> free_list;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (curr) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (curr<span style=color:#f92672>-&gt;</span>is_free <span style=color:#f92672>&amp;&amp;</span> curr<span style=color:#f92672>-&gt;</span>size <span style=color:#f92672>&gt;=</span> size) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Found a suitable block; remove it from the free list
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> (prev) {
</span></span><span style=display:flex><span>                prev<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> curr<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                free_list <span style=color:#f92672>=</span> curr<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            curr<span style=color:#f92672>-&gt;</span>is_free <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>            curr<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[my_malloc] Reused free block of size &#34;</span> <span style=color:#f92672>&lt;&lt;</span> curr<span style=color:#f92672>-&gt;</span>size <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; bytes</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>void</span><span style=color:#f92672>*&gt;</span>(curr <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        prev <span style=color:#f92672>=</span> curr;
</span></span><span style=display:flex><span>        curr <span style=color:#f92672>=</span> curr<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// If no free block is found, request memory from the OS (mmap)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> memory <span style=color:#f92672>=</span> request_memory_from_os(size);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>memory) <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    BlockHeader<span style=color:#f92672>*</span> header <span style=color:#f92672>=</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span>BlockHeader<span style=color:#f92672>*&gt;</span>(memory);
</span></span><span style=display:flex><span>    header<span style=color:#f92672>-&gt;</span>size <span style=color:#f92672>=</span> size;
</span></span><span style=display:flex><span>    header<span style=color:#f92672>-&gt;</span>is_free <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>    header<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>void</span><span style=color:#f92672>*&gt;</span>(header <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I also implement a thread-safe wrapper around the above function (<code>my_malloc_internal</code>) to complete the <code>my_malloc</code> implementation. A heap mutex is used to make the function thread-safe.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>my_malloc</span>(std<span style=color:#f92672>::</span>size_t size) {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>lock_guard<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>mutex<span style=color:#f92672>&gt;</span> lock(heap_mutex);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> my_malloc_internal(size);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h3 id=free><strong>Free</strong>
<a class=heading-link href=#free><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>In <code>free</code>, we take the pointer to memory as that memory block is to be freed. Since the pointer input is the start of the usable memory, we decrement 1 from it to point to the block header itself. We then set the free boolean to <code>true</code> in that block header and push the freed block to the front of the linked list of free blocks.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>my_free_internal</span>(<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> ptr) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>ptr) <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    BlockHeader<span style=color:#f92672>*</span> header <span style=color:#f92672>=</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span>BlockHeader<span style=color:#f92672>*&gt;</span>(ptr) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Double free protection: check if block is already free
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (header<span style=color:#f92672>-&gt;</span>is_free) {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cerr <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[ERROR] Double free detected! Block at &#34;</span> <span style=color:#f92672>&lt;&lt;</span> ptr <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; is already free.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>; <span style=color:#75715e>// Don&#39;t free again
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    header<span style=color:#f92672>-&gt;</span>is_free <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Push the freed block onto the front of the free list (LIFO)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    header<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> free_list;
</span></span><span style=display:flex><span>    free_list <span style=color:#f92672>=</span> header;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h3 id=calloc><strong>Calloc</strong>
<a class=heading-link href=#calloc><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>Different from <code>malloc</code>, <code>calloc</code> gives us zero-initialized memory. Hence, on top of allocating an unused memory region, we also need to set this memory to 0 (<a href=https://stackoverflow.com/questions/1538420/difference-between-malloc-and-calloc class=external-link target=_blank rel=noopener>reference</a>).</p><p>Also, <code>calloc</code> is different argument-wise in that it allocates memory for an array of <code>num</code> objects of <code>size</code> bytes each and initializes all bytes in the allocated storage to zero. So it takes two arguments (<code>num</code> and <code>size</code>), as opposed to only <code>size</code> in <code>malloc</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>my_calloc</span>(std<span style=color:#f92672>::</span>size_t num, std<span style=color:#f92672>::</span>size_t size) {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>lock_guard<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>mutex<span style=color:#f92672>&gt;</span> lock(heap_mutex);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (num <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> size <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    size_t total <span style=color:#f92672>=</span> num <span style=color:#f92672>*</span> size;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (size <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> total <span style=color:#f92672>/</span> size <span style=color:#f92672>!=</span> num) {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cerr <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;[my_calloc] Integer overflow detected!</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> memory <span style=color:#f92672>=</span> my_malloc_internal(total);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>memory) <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>memset(memory, <span style=color:#ae81ff>0</span>, total);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> memory;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h3 id=realloc><strong>Realloc</strong>
<a class=heading-link href=#realloc><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p><code>realloc</code> takes two arguments: the memory pointer to reallocate and the new size. There are some nuances to consider in <code>realloc</code>:</p><ul><li><strong>New size &lt; original size:</strong> shrink in place, update size in header, same pointer returned.</li><li><strong>New size = original size:</strong> no change, same pointer returned.</li><li><strong>New size > original size:</strong> allocate new block, copy old data, free old block.</li></ul><p>If the new size is <code>0</code>, we free the pointer. If the new size is equal to the original size, we simply return the pointer. If the new size is smaller, we update the size field in our header but keep the same pointer.</p><p>If the new size is greater, we allocate a new pointer with <code>malloc</code>, copy the original memory region into it, free the old region, and return the new pointer.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>my_realloc</span>(<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> ptr, std<span style=color:#f92672>::</span>size_t size) {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>lock_guard<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>mutex<span style=color:#f92672>&gt;</span> lock(heap_mutex);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>ptr) <span style=color:#66d9ef>return</span> my_malloc_internal(size);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (size <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        my_free_internal(ptr);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    BlockHeader<span style=color:#f92672>*</span> header <span style=color:#f92672>=</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span>BlockHeader<span style=color:#f92672>*&gt;</span>(ptr) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (size <span style=color:#f92672>==</span> header<span style=color:#f92672>-&gt;</span>size) <span style=color:#66d9ef>return</span> ptr;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (size <span style=color:#f92672>&lt;</span> header<span style=color:#f92672>-&gt;</span>size) {
</span></span><span style=display:flex><span>        header<span style=color:#f92672>-&gt;</span>size <span style=color:#f92672>=</span> size;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> ptr;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> new_ptr <span style=color:#f92672>=</span> my_malloc_internal(size);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>new_ptr) <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>memcpy(new_ptr, ptr, header<span style=color:#f92672>-&gt;</span>size);
</span></span><span style=display:flex><span>    my_free_internal(ptr);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> new_ptr;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h3 id=learning-outcomes><strong>Learning Outcomes</strong>
<a class=heading-link href=#learning-outcomes><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>This project demonstrates key concepts in systems programming and memory management:</p><ul><li><strong>Memory Allocation</strong>: Best-fit allocation with free list management</li><li><strong>Data Structures</strong>: Linked list for tracking free memory blocks</li><li><strong>System Calls</strong>: Direct OS memory interaction via <code>mmap</code></li><li><strong>Memory Safety</strong>: Double-free detection and prevention</li><li><strong>Concurrency</strong>: Thread-safe allocation with mutex synchronization</li><li><strong>Error Handling</strong>: Edge case management and validation</li><li><strong>Memory Layout</strong>: Block headers and memory organization</li><li><strong>Performance</strong>: Efficient memory reuse and reallocation strategies</li></ul><p>You may reach the source code from this link:
🔗 <a href=https://github.com/memduhb/custom_memory_allocator class=external-link target=_blank rel=noopener>https://github.com/memduhb/custom_memory_allocator</a></p></div><footer><section class=see-also><h3 id=see-also-in-memory-management>See also in memory-management
<a class=heading-link href=#see-also-in-memory-management><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><nav><ul><li><a href=/posts/implementing-custom-thread-pool-cpp/>Implementing Custom Thread Pool in C++</a></li><li><a href=/posts/slab-allocator-implementation/>Implementing Custom Slab Allocator with C++</a></li></ul></nav></section></footer></article></section></div><footer class=footer><section class=container>©
2025
memduh
·
Powered by <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script></body></html>