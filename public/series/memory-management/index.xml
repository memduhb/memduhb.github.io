<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Memory-Management on memduh</title><link>/series/memory-management/</link><description>Recent content in Memory-Management on memduh</description><generator>Hugo</generator><language>en</language><lastBuildDate>Thu, 07 Aug 2025 10:00:00 +0300</lastBuildDate><atom:link href="/series/memory-management/index.xml" rel="self" type="application/rss+xml"/><item><title>Implementing Custom Thread Pool in C++</title><link>/posts/implementing-custom-thread-pool-cpp/</link><pubDate>Thu, 07 Aug 2025 10:00:00 +0300</pubDate><guid>/posts/implementing-custom-thread-pool-cpp/</guid><description/></item><item><title>Implementing Custom Memory Allocator in C++</title><link>/posts/custom-memory-allocator-implementation/</link><pubDate>Wed, 06 Aug 2025 10:00:00 +0300</pubDate><guid>/posts/custom-memory-allocator-implementation/</guid><description>&lt;p>In this post, I elaborate on my implementation of a memory allocator in C++. The &lt;code>malloc&lt;/code>, &lt;code>calloc&lt;/code>, &lt;code>realloc&lt;/code>, and &lt;code>free&lt;/code> functions are implemented and discussed. The aim is to provide educational content on how these functions work under the hood. Not all aspects are taken into account in this custom implementation; however, this provides a sufficient introduction to memory management in C++. Note that standard allocators like &lt;strong>glibc malloc&lt;/strong> are highly optimized and have been battle-tested for decades.&lt;/p></description></item><item><title>Implementing Custom Slab Allocator with C++</title><link>/posts/slab-allocator-implementation/</link><pubDate>Sat, 25 Jan 2025 09:15:00 +0300</pubDate><guid>/posts/slab-allocator-implementation/</guid><description>&lt;p>nothing to see here&lt;/p></description></item></channel></rss>